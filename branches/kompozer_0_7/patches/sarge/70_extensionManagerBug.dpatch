#!/bin/sh -e
## 50_mozilla-firebird-mips-xptcstubs-gcc3.dpatch by Alexander Sack <asac@jwsdot.com>
##
## All lines beginning with `## DP:' are a description of the patch.
## DP: No description.

if [ $# -ne 1 ]; then
    echo >&2 "`basename $0`: script expects -patch|-unpatch as argument"
    exit 1
fi

[ -f debian/patches/00patch-opts ] && . debian/patches/00patch-opts
patch_opts="${patch_opts:--f --no-backup-if-mismatch}"

case "$1" in
       -patch) patch $patch_opts -p1 < $0;;
       -unpatch) patch $patch_opts -p1 -R < $0;;
        *)
                echo >&2 "`basename $0`: script expects -patch|-unpatch as argument"
                exit 1;;
esac

exit 0

@DPATCH@
--- mozilla.orig/toolkit/mozapps/extensions/content/extensions.js
+++ mozilla/toolkit/mozapps/extensions/content/extensions.js
@@ -678,7 +678,8 @@
       return !selectedItem ||
              (selectedItem &&
               selectedItem.getAttribute("toBeUninstalled") != "true" &&
-              selectedItem.getAttribute("toBeInstalled") != "true");
+              selectedItem.getAttribute("toBeInstalled") != "true" &&
+	      selectedItem.getAttribute("locked") != "true");
     case "cmd_reallyEnable":
     // controls whether to show Enable or Disable in extensions' context menu
       return selectedItem && 
--- mozilla.orig/toolkit/mozapps/extensions/src/nsExtensionManager.js.in
+++ mozilla/toolkit/mozapps/extensions/src/nsExtensionManager.js.in
@@ -20,6 +20,7 @@
  *
  * Contributor(s):
  *  Ben Goodger <ben@bengoodger.com>
+ *  Mike Hommey <mh@glandium.org>
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either the GNU General Public License Version 2 or later (the "GPL"), or
@@ -144,6 +145,19 @@
 }
 
 // Returns the file at the appropriate point in a directory hierarchy under
+// the specified key. Does NOT create the file NOR the directories along the
+// way.
+function getFileNoCreateDir(aKey, aPathToFile)
+{
+  var subdirs = [];
+  for (var i = 0; i < aPathToFile.length - 1; ++i)
+    subdirs.push(aPathToFile[i]);
+  var file = getDirNoCreate(aKey, subdirs);
+  file.append(aPathToFile[aPathToFile.length - 1]);
+  return file;
+}
+
+// Returns the file at the appropriate point in a directory hierarchy under
 // the specified key, creating directories along the way if necessary. Does
 // NOT create the file.
 function getFile(aKey, aPathToFile)
@@ -675,7 +689,7 @@
 function nsInstallLogReader(aExtensionID, aIsProfile, aListener)
 {
   this._isProfile = aIsProfile;
-  this.uninstallLog = getFile(getDirKey(aIsProfile),
+  this.uninstallLog = getFileNoCreateDir(getDirKey(aIsProfile),
                               [DIR_EXTENSIONS, aExtensionID, 
                                DIR_UNINSTALL, FILE_UNINSTALL_LOG]);
   this._listener = aListener
@@ -829,26 +843,20 @@
   {
     // extension,{GUID} or theme,{GUID}
     var parts = aLine.split(",");
-    var manifest = getFile(KEY_APPDIR, 
+    var manifest = getFileNoCreateDir(KEY_APPDIR, 
                            [DIR_EXTENSIONS, parts[1], FILE_INSTALL_MANIFEST]);
     if (parts.length != 2)
       return;
       
-    if (!manifest.exists()) {
-      defaultManifest = defaultFile = getFile(KEY_DEFAULTS, 
-                                              [DIR_DEFAULTS_EXTENSIONS, parts[1], FILE_INSTALL_MANIFEST]);
-      var extensionDir = getDir(KEY_APPDIR, [DIR_EXTENSIONS, parts[1]]);
-      defaultManifest.copyTo(extensionDir, FILE_INSTALL_MANIFEST);
-      manifest = getFile(KEY_APPDIR, 
-                         [DIR_EXTENSIONS, parts[1], FILE_INSTALL_MANIFEST]);
-    }
-    switch (parts[0]) {
-    case this.TOKEN_EXTENSION:
-      this._manager.ensurePreConfiguredItem(parts[1], nsIUpdateItem.TYPE_EXTENSION, manifest);
-      break;
-    case this.TOKEN_THEME:
-      this._manager.ensurePreConfiguredItem(parts[1], nsIUpdateItem.TYPE_THEME, manifest);
-      break;
+    if (manifest.exists()) {
+      switch (parts[0]) {
+      case this.TOKEN_EXTENSION:
+        this._manager.ensurePreConfiguredItem(parts[1], nsIUpdateItem.TYPE_EXTENSION, manifest);
+        break;
+      case this.TOKEN_THEME:
+        this._manager.ensurePreConfiguredItem(parts[1], nsIUpdateItem.TYPE_THEME, manifest);
+        break;
+      }
     }
   }
 };
@@ -917,21 +925,26 @@
     this._writer = new nsInstallLogWriter(this._extensionID, this._isProfile);
     this._writer.open();
     
-    // Move files from the staging dir into the extension's final home.
-    // This function generates uninstall log files and creates backups of
-    // existing files. 
-    // XXXben - would like to add exception handling here to test for file
-    //          I/O failures on uninstall log so that if there's a crash
-    //          and the uninstall log is incorrectly/incompletely written 
-    //          we can roll back. It's not critical that we do so right now
-    //          since if this throws the extension's chrome is never 
-    //          registered. 
-    this._installExtensionFiles();
-    
     // Load the metadata datasource
-    var metadataFile = getFile(this._extDirKey, 
+    var metadataFile = getFileNoCreateDir(this._extDirKey, 
                                [DIR_EXTENSIONS, aExtensionID, FILE_INSTALL_MANIFEST]);
     
+    // If the metadata file exists, it means we don't have to to extract the xpi.
+    // Useful for pre-configured extensions.
+
+    if (aIsProfile && !metadataFile.exists()) {
+      // Move files from the staging dir into the extension's final home.
+      // This function generates uninstall log files and creates backups of
+      // existing files. 
+      // XXXben - would like to add exception handling here to test for file
+      //          I/O failures on uninstall log so that if there's a crash
+      //          and the uninstall log is incorrectly/incompletely written 
+      //          we can roll back. It's not critical that we do so right now
+      //          since if this throws the extension's chrome is never 
+      //          registered. 
+      this._installExtensionFiles();
+    }
+
     this._metadataDS = getInstallManifest(metadataFile);
     if (!this._metadataDS) return;
     
@@ -1752,6 +1765,9 @@
       // Write bin/components.ini
       var manifest = getFile(KEY_APPDIR, [FILE_COMPONENT_MANIFEST]);
       this._writeProfileFile(manifest, this._getComponentsDir, false);
+
+      // Update the Defaults Manifest
+      this._writeDefaults(false);
     }
   },
 
@@ -1823,7 +1839,7 @@
         cr.selectSkin(KEY_DEFAULT_THEME, true);
       }
       catch (e) {
-        dump("*** nsExtensionManager::_disableObsoleteExtensions - failure, catching exception so finalize window can close\n");
+//        dump("*** nsExtensionManager::_disableObsoleteExtensions - failure, catching exception so finalize window can close\n");
       }
       win.close();
       
@@ -2002,6 +2018,34 @@
     this._ds.insertForthcomingItem(aItemID, aItemType, false);
     var metadataDS = getInstallManifest(aManifest);
     this._ds.addItemMetadata(aItemID, aItemType, metadataDS, false);
+
+    // Check whether the extension is installable (thunderbird_version fitting between
+    // em:MaxVersion and em:MinVersion)
+    var extensionID = this.canInstallItem(metadataDS);
+    // |extensionID| must be a GUID string, not a number - a number means failure.
+    if (isNaN(parseInt(extensionID))) {
+      // Do install the extension, meaning we register its chrome and components
+      if (!this._extInstaller)
+          this._extInstaller = new nsExtensionInstaller(this._ds);
+      try {
+          this._extInstaller.install(aItemID, false);
+      }
+      catch (e) {
+          // If the installation failed, we disable the extension in addition
+	  // to _not_ uninstalling it (which would fail anyway because it
+	  // would be done at launch time... as a user).
+	  this._ds.setItemProperty(aItemID, this._ds._emR("toBeUninstalled"),
+	                           null, false, aItemType);
+          this._ds.setItemProperty(aItemID, this._ds._emR("disabled"),
+                                   this._ds._emL("true"), false, aItemType);
+      }
+    } else {
+      // disable extensions that aren't installable
+      this._ds.setItemProperty(aItemID, this._ds._emR("disabled"),
+                              this._ds._emL("true"), false, aItemType);
+    }
+    // Force locking pre-configured items.
+    this._ds.lockUnlockItem(aItemID, true);
   },
   
   checkForMismatches: function nsExtensionManager_checkForMismatches () 
@@ -2028,22 +2072,31 @@
       if (items.length > 0) {
         for (var i = 0; i < items.length; ++i) {
           // Now disable the extension so it won't hurt anything. 
+	  var alreadyDisabled = this._ds.getItemProperty(items[i].id, "disabled");
           var itemType = getItemType(this._ds._getResourceForItem(items[i].id).Value);
           if (itemType != -1 && itemType & nsIUpdateItem.TYPE_EXTENSION)
-            this.disableExtension(items[i].id);
+            if (!alreadyDisabled) this.disableExtension(items[i].id);
           else if (itemType & nsIUpdateItem.TYPE_THEME) {
             if (gPref.prefHasUserValue(PREF_GENERAL_SKINS_SELECTEDSKIN))
               gPref.clearUserPref(PREF_GENERAL_SKINS_SELECTEDSKIN);
-            this._ds.disableTheme(items[i].id);
+            if (!alreadyDisabled) this._ds.disableTheme(items[i].id);
           }
         }
-        var updates = Components.classes["@mozilla.org/updates/update-service;1"]
-                                .getService(Components.interfaces.nsIUpdateService);
-        updates.checkForUpdates(items, items.length, nsIUpdateItem.TYPE_ADDON, 
-                                nsIUpdateService.SOURCE_EVENT_MISMATCH,
-                                null);
+	// We want to eliminate locked extensions
+	newitems = [];
+	for (var i = 0; i < items.length; ++i) {
+	  if (!this._ds.getItemProperty(items[i].id, "locked"))
+	    newitems.push(items[i]);
+	}
+	if (newitems.length > 0) {
+          var updates = Components.classes["@mozilla.org/updates/update-service;1"]
+                                  .getService(Components.interfaces.nsIUpdateService);
+          updates.checkForUpdates(newitems, newitems.length, nsIUpdateItem.TYPE_ADDON, 
+                                  nsIUpdateService.SOURCE_EVENT_MISMATCH,
+                                  null);
         
-        needsRestart = true;
+          needsRestart = true;
+	}
       }
     }
     
@@ -2087,7 +2140,7 @@
       this._writeDefaults(false);
     }
     catch (e) { 
-      dump("*** ExtensionManager:_updateManifests: no access privileges to application directory, skipping.\n"); 
+//      dump("*** ExtensionManager:_updateManifests: no access privileges to application directory, skipping.\n"); 
     };
     this._writeComponentManifest(true);
     this._writeDefaults(true);
@@ -2133,6 +2186,11 @@
         validExtensions.push({ sourceDir: sourceDir, isProfile: isProfile });
     }
     
+    // Debian hook to insert defaults/syspref into defaults.ini
+    if ((aFile.leafName == FILE_DEFAULTS) && aIsProfile == false) {
+      validExtensions.push({ sourceDir: getDirNoCreate(getDirKey(false), [DIR_DEFAULTS, "syspref"]), isProfile: false });
+    }
+
     var lines = ["[Extra Files]\r\n",
                  "Count=" + validExtensions.length + "\r\n"];
     for (i = 0; i < lines.length; ++i)
@@ -3090,8 +3148,10 @@
   checkForUpdates: function (aItem, aVersionUpdateOnly)
   {
     // A preference setting can disable updating for this item
+    // We'll also skip locked items.
     try {
-      if (!gPref.getBoolPref(PREF_EM_ITEM_UPDATE_ENABLED.replace(/%UUID%/, aItem.id))) {
+      if (this._updater._emDS.getItemProperty(aItem.id, "locked") ||
+          !gPref.getBoolPref(PREF_EM_ITEM_UPDATE_ENABLED.replace(/%UUID%/, aItem.id))) {
         gOS.notifyObservers(null, "Update:Extension:Item-Ended", "");
         this._updater._checkForDone();
         return;
@@ -3557,7 +3617,7 @@
   
   isProfileItem: function nsExtensionsDataSource_isProfileItem (aItemID)
   {
-    return this.getItemProperty(aItemID, "installLocation") != "global";
+    return this.getItemProperty(aItemID, "installLocation") == "profile";
   },
   
   _setProperty: function nsExtensionsDataSource__setProperty (aDS, aSource, aProperty, aNewValue)
--- mozilla.orig/toolkit/mozapps/update/src/nsUpdateService.js.in
+++ mozilla/toolkit/mozapps/update/src/nsUpdateService.js.in
@@ -178,9 +178,10 @@
       if (aRequestedTypes & nsIUpdateItem.TYPE_THEME)
         types |= nsIUpdateItem.TYPE_THEME;
     }
-    if (appUpdateEnabled && 
-        (aRequestedTypes & nsIUpdateItem.TYPE_APP))
-      types |= nsIUpdateItem.TYPE_APP;
+    // Disable application updates
+    //if (appUpdateEnabled && 
+    //    (aRequestedTypes & nsIUpdateItem.TYPE_APP))
+    //  types |= nsIUpdateItem.TYPE_APP;
 
     return types;
   },
